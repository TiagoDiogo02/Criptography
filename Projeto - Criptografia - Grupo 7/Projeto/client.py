# Cliente.py

import socket
import ssl
import json
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os
import base64

# Vari√°veis globais para as chaves do cliente
client_private_key = None
client_public_key = None

# Fun√ß√£o para carregar ou gerar par de chaves RSA para o cliente
def load_or_generate_keys(id_origin):
    private_key_path = f'client_private_key_{id_origin}.pem'
    public_key_path = f'client_public_key_{id_origin}.pem'
    
    if os.path.exists(private_key_path) and os.path.exists(public_key_path):
        # Carregar as chaves existentes
        with open(private_key_path, 'rb') as f:
            private_key = serialization.load_pem_private_key(f.read(), password=None)
        with open(public_key_path, 'rb') as f:
            public_key = serialization.load_pem_public_key(f.read())
        print("üîë Chaves carregadas do arquivo espec√≠fico do cliente.")
    else:
        # Gerar novas chaves
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        public_key = private_key.public_key()
        
        # Guardar as chaves em arquivos espec√≠ficos deste cliente
        with open(private_key_path, 'wb') as f:
            f.write(private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ))
        with open(public_key_path, 'wb') as f:
            f.write(public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            ))
        print("üîë Novas chaves geradas e guardadas para este cliente.")
    
    return private_key, public_key

# Fun√ß√£o para criptografar o conte√∫do usando AES
def encrypt_content(content):
    key = os.urandom(32)  # Gera uma chave aleat√≥ria de 256 bits
    nonce = os.urandom(12)  # Gera um nonce aleat√≥rio de 96 bits
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce))
    encryptor = cipher.encryptor()
    encrypted_content = encryptor.update(content.encode()) + encryptor.finalize()
    # Concatenar tag, nonce e conte√∫do criptografado e codificar em base64
    return base64.b64encode(encryptor.tag + nonce + encrypted_content).decode('utf-8'), key

# Fun√ß√£o para decifrar o conte√∫do
def decrypt_content(encrypted_content, key):
    try:
        data = base64.b64decode(encrypted_content)
    except Exception as e:
        print("‚ö†Ô∏è Erro ao decifrar o conte√∫do em base64:", e)
        return None
    try:
        tag = data[:16]       
        nonce = data[16:28]   
        encrypted_data = data[28:]  
        cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag))
        decryptor = cipher.decryptor()
        return decryptor.update(encrypted_data) + decryptor.finalize()
    except Exception as e:
        print("‚ö†Ô∏è Erro ao decifrar o conte√∫do:", e)
        return None

# Fun√ß√£o para criptografar a chave AES com a chave p√∫blica do destinat√°rio
def encrypt_key_with_recipient_public_key(key, recipient_public_key):
    encrypted_key = recipient_public_key.encrypt(
        key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return base64.b64encode(encrypted_key).decode('utf-8')

# Fun√ß√£o para decifrar a chave AES com a chave privada do destinat√°rio
def decrypt_key_with_private_key(encrypted_key):
    global client_private_key
    encrypted_key_bytes = base64.b64decode(encrypted_key)
    key = client_private_key.decrypt(
        encrypted_key_bytes,
        padding.OAEP(
            mgf=padding.MGF1(hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return key

# Fun√ß√£o para se conectar ao servidor de forma segura (SSL)
def secure_connect():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    context = ssl.create_default_context()
    
    # Carregar o certificado do servidor como CA confi√°vel
    context.load_verify_locations('server_cert.pem')  
    
    # Exigir a verifica√ß√£o do certificado
    context.verify_mode = ssl.CERT_REQUIRED  
    
    # Definir o nome do host para correspond√™ncia com o CN do certificado
    secure_socket = context.wrap_socket(client_socket, server_hostname="192.168.137.1")  
    
    secure_socket.connect(("192.168.137.1", 9999))  
    return secure_socket

# Dicion√°rio para armazenar chaves p√∫blicas de outros clientes (cache)
cached_public_keys = {}

def get_public_key(id_requested, token):
    if id_requested in cached_public_keys:
        return cached_public_keys[id_requested]
    
    secure_socket = secure_connect()
    request = {
        "action": "get_public_key",
        "token": token, 
        "id_requested": id_requested
    }
    secure_socket.send(json.dumps(request).encode())
    response = secure_socket.recv(4096)
    
    try:
        response_data = json.loads(response.decode())
    except json.JSONDecodeError:
        print("‚ö†Ô∏è Erro: Resposta inv√°lida do servidor ao obter a chave p√∫blica.")
        secure_socket.close()
        return None
    
    secure_socket.close()
    
    if "public_key" in response_data:
        public_key_pem = response_data["public_key"]
        public_key = serialization.load_pem_public_key(public_key_pem.encode())
        cached_public_keys[id_requested] = public_key 
        return public_key
    else:
        print("‚ö†Ô∏è Erro ao obter chave p√∫blica:", response_data.get("error"))
        return None

def register_client(id_origin):
    global client_private_key, client_public_key
    password = input("üîí Crie a sua senha: ").strip()
    confirm_password = input("üîí Confirme a sua senha: ").strip()

    if password != confirm_password:
        print("‚ö†Ô∏è Erro: As senhas n√£o coincidem.")
        return

    secure_socket = secure_connect()
    public_key_pem = client_public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    request = {
        "action": "register",
        "id_origin": id_origin,
        "password": password,
        "public_key": public_key_pem.decode()
    }
    secure_socket.send(json.dumps(request).encode())
    response = secure_socket.recv(4096)
    try:
        response_data = json.loads(response.decode())
        if "error" in response_data:
            print("‚ö†Ô∏è Erro:", response_data.get("error"))
        else:
            print("üì¨ Resposta do servidor:", response_data.get("status", "Registo bem-sucedido."))
    except json.JSONDecodeError:
        print("üì¨ Resposta do servidor:", response.decode())
    secure_socket.close()

def login_client(id_origin):
    password = input("üîë Informe a sua senha: ").strip()
    secure_socket = secure_connect()
    request = {
        "action": "login",
        "id_origin": id_origin,
        "password": password
    }
    secure_socket.send(json.dumps(request).encode())
    response = secure_socket.recv(4096)
    try:
        response_data = json.loads(response.decode())
        if "error" in response_data:
            print("‚ö†Ô∏è Erro:", response_data.get("error"))
            return None
        else:
            print("‚úÖ", response_data.get("status", "Login bem-sucedido."))
            return response_data.get("token")
    except json.JSONDecodeError:
        print("‚ö†Ô∏è Erro: Resposta inv√°lida do servidor.")
        return None
    finally:
        secure_socket.close()

def send_message(id_origin, token):
    global client_private_key, client_public_key
    id_destination = input("üîπ Informe o ID do destinat√°rio: ").strip()
    subject = input("üìù Informe o assunto da mensagem: ").strip()
    content = input("üì® Informe o conte√∫do da mensagem: ").strip()
    
    if len(subject) > 50:
        print("‚ö†Ô∏è Erro: Assunto excede 50 caracteres.")
        return

    # Obter a chave p√∫blica do destinat√°rio, passando o token
    recipient_public_key = get_public_key(id_destination, token)
    if recipient_public_key is None:
        print("‚ö†Ô∏è Erro: N√£o foi poss√≠vel obter a chave p√∫blica do destinat√°rio.")
        return

    # Criptografar o conte√∫do
    encrypted_content, key = encrypt_content(content)  # Criptografa o conte√∫do com AES
    # Criptografar a chave AES com a chave p√∫blica do destinat√°rio
    encrypted_key = encrypt_key_with_recipient_public_key(key, recipient_public_key)
    
    # Assinar o conte√∫do criptografado
    signature = client_private_key.sign(
        encrypted_content.encode(),
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    encoded_signature = base64.b64encode(signature).decode('utf-8')

    # Logs de depura√ß√£o
    print("üîê Conte√∫do Criptografado:", encrypted_content)
    print("‚úçÔ∏è Assinatura (base64):", encoded_signature)

    # Preparar a mensagem para enviar
    message = {
        "action": "send",
        "token": token,  
        "id_origin": id_origin,
        "id_destination": id_destination,
        "subject": subject,
        "content": encrypted_content,
        "signature": encoded_signature,
        "key": encrypted_key  # Chave AES criptografada
    }

    # Enviar a mensagem ao servidor
    secure_socket = secure_connect()
    secure_socket.send(json.dumps(message).encode())
    response = secure_socket.recv(4096)
    try:
        response_data = json.loads(response.decode())
        if "error" in response_data:
            print("‚ö†Ô∏è Erro ao enviar mensagem:", response_data["error"])
        else:
            print("‚úÖ Mensagem enviada com sucesso! ID da mensagem:", response_data["msg_id"])
    except json.JSONDecodeError:
        print("‚ö†Ô∏è Erro: Resposta inv√°lida do servidor.")
    secure_socket.close()

def consult_all_messages(id_origin, token):
    secure_socket = secure_connect()
    request = {
        "action": "consult_all",
        "token": token,
        "id_destination": id_origin
    }
    secure_socket.send(json.dumps(request).encode())
    response = secure_socket.recv(4096)
    try:
        messages = json.loads(response.decode())
        print("\nüì• Todas as mensagens recebidas:")
        if not messages:
            print("Nenhuma mensagem encontrada.")
        else:
            for msg in messages:
                print(f"ID: {msg['id']} | De: {msg['id_origin']} | Assunto: {msg['subject']} | Lida: {'Sim' if msg['read'] else 'N√£o'}")
    except json.JSONDecodeError:
        print("‚ö†Ô∏è Erro ao decifrar a resposta do servidor.")
    secure_socket.close()

def consult_new_messages(id_origin, token):
    secure_socket = secure_connect()
    request = {
        "action": "consult_new",
        "token": token,
        "id_destination": id_origin
    }
    secure_socket.send(json.dumps(request).encode())
    response = secure_socket.recv(4096)
    try:
        messages = json.loads(response.decode())
        print("\nüì• Novas mensagens:")
        if not messages:
            print("Nenhuma nova mensagem encontrada.")
        else:
            for msg in messages:
                print(f"ID: {msg['id']} | De: {msg['id_origin']} | Assunto: {msg['subject']} | Data: {msg['timestamp']}")
    except json.JSONDecodeError:
        print("‚ö†Ô∏è Erro ao decifrar a resposta do servidor.")
    secure_socket.close()

def read_message(id_origin, token):
    global client_private_key, client_public_key
    try:
        id_msg_input = input("üì¨ Informe o ID da mensagem que deseja ler: ").strip()
        id_msg = int(id_msg_input)
    except ValueError:
        print("‚ö†Ô∏è Erro: Por favor, insira um ID de mensagem v√°lido (n√∫mero).")
        return
    
    secure_socket = secure_connect()
    request = {
        "action": "read_message",
        "token": token,
        "id_destination": id_origin,
        "id_msg": id_msg
    }
    secure_socket.send(json.dumps(request).encode())
    response = secure_socket.recv(4096)
    
    try:
        message = json.loads(response.decode())
    
        if "id_origin" in message:
            # Decifrar a chave AES
            encrypted_key = message['key']
            key = decrypt_key_with_private_key(encrypted_key)  
            
            # Decifrar o conte√∫do
            decrypted_content = decrypt_content(message['content'], key)
            if decrypted_content is None:
                print("‚ö†Ô∏è Erro: N√£o foi poss√≠vel decifrar o conte√∫do. A mensagem pode ter sido adulterada.")
                return
            
            # Obter a chave p√∫blica do remetente
            sender_public_key = get_public_key(message['id_origin'], token)
            if sender_public_key is None:
                print("‚ö†Ô∏è N√£o foi poss√≠vel verificar a assinatura sem a chave p√∫blica do remetente.")
                return
            
            # Verificar a assinatura
            signature = base64.b64decode(message['signature'])
            try:
                sender_public_key.verify(
                    signature,
                    message['content'].encode(),  # Verifica a assinatura no conte√∫do criptografado
                    padding.PSS(
                        mgf=padding.MGF1(hashes.SHA256()),
                        salt_length=padding.PSS.MAX_LENGTH
                    ),
                    hashes.SHA256()
                )
                signature_valid = True
            except Exception as e:
                signature_valid = False
                print("‚ö†Ô∏è Assinatura inv√°lida:", e)
            
            print("\nüì® Mensagem:")
            print(f"De: {message['id_origin']} | Para: {message['id_destination']} | Assunto: {message['subject']}")
            print(f"Data: {message['timestamp']}")
            print(f"Conte√∫do: {decrypted_content.decode('utf-8')}")
            print(f"Assinatura v√°lida: {'Sim' if signature_valid else 'N√£o'}")
        elif "error" in message:
            print("‚ö†Ô∏è Erro:", message["error"])
        else:
            print("‚ö†Ô∏è Resposta inesperada do servidor.")
    except json.JSONDecodeError:
        print("‚ö†Ô∏è Erro: resposta inesperada do servidor.")
    finally:
        secure_socket.close()

def delete_message(id_origin, token):
    try:
        id_msg = int(input("üóëÔ∏è Informe o ID da mensagem que deseja excluir: ").strip())
    except ValueError:
        print("‚ö†Ô∏è Erro: Por favor, insira um ID de mensagem v√°lido (n√∫mero).")
        return
    
    secure_socket = secure_connect()
    request = {
        "action": "delete_message",
        "token": token,
        "id_destination": id_origin,
        "id_msg": id_msg
    }
    secure_socket.send(json.dumps(request).encode())
    response = secure_socket.recv(4096)
    try:
        response_data = json.loads(response.decode())
        if "error" in response_data:
            print("‚ö†Ô∏è Erro:", response_data["error"])
        else:
            print("üóëÔ∏è Resposta do servidor:", response_data.get("status", "Mensagem exclu√≠da com sucesso."))
    except json.JSONDecodeError:
        print("üóëÔ∏è Resposta do servidor:", response.decode())
    secure_socket.close()

def display_menu():
    print("\nüåê  Sistema de Mensagens Seguras  üåê")
    print(""" 
    ‚îÄ‚îÄ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ‚îÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñÑ‚ñÄ‚ñÄ‚ñÑ‚îÄ
    ‚ñë‚ñà‚ñà‚îÄ‚ñÄ‚îÄ‚ñà‚ñà‚ñë‚ñë‚ñà‚ñÄ‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà‚ñë‚ñë‚ñà‚ñë
    ‚ñë‚ñà‚ñà‚ñà‚ñÑ‚ñà‚ñà‚ñà‚ñë‚ñë‚ñÄ‚ñë‚ñÄ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÄ‚ñÄ‚ñë‚ñë
    \nCripto Trabalho Pr√°tico
        """)
    print("üìú **Menu de Op√ß√µes**")
    print("1 - ‚úâÔ∏è  Enviar mensagem")
    print("2 - üì¨ Consultar todas as mensagens")
    print("3 - üÜï Consultar novas mensagens")
    print("4 - üì® Ler uma mensagem")
    print("5 - üóëÔ∏è  Excluir uma mensagem")
    print("6 - üö™ Sair")

def main():
    global client_private_key, client_public_key
    id_origin = input("üÜî Informe seu ID: ").strip()
    # Carregar ou gerar um par de chaves distinto para este cliente
    client_private_key, client_public_key = load_or_generate_keys(id_origin)
    
    # Realizar o login ou registo
    while True:
        print("\nüîí **Autentica√ß√£o**")
        print("1 - üîê Login")
        print("2 - üìù Registrar novo cliente")
        choice = input("‚û°Ô∏è  Escolha uma op√ß√£o (1-2): ").strip()

        if choice == "1":
            token = login_client(id_origin)
            if token:
                break
        elif choice == "2":
            register_client(id_origin)
        else:
            print("‚ö†Ô∏è Op√ß√£o inv√°lida. Tente novamente.")

    # Loop principal de opera√ß√µes
    while True:
        display_menu()
        choice = input("‚û°Ô∏è  Escolha uma op√ß√£o (1-6): ").strip()

        if choice == "1":
            send_message(id_origin, token)

        elif choice == "2":
            consult_all_messages(id_origin, token)

        elif choice == "3":
            consult_new_messages(id_origin, token)

        elif choice == "4":
            read_message(id_origin, token)

        elif choice == "5":
            delete_message(id_origin, token)

        elif choice == "6":
            print("üëã Saindo...")
            break

        else:
            print("‚ö†Ô∏è Op√ß√£o inv√°lida. Tente novamente.")

if __name__ == "__main__":
    main()
